[{"body":" Summary Use the OEPlacement() function on a list of optical elements, a SourceProperties dictionnary, a list of distances and a list of incidence angles. Explanation The first argument of main() is OpticalChainList, a complete description of the optical setup that needs to be simulated. This includes the absolute positions and orientations of all the optical elements apart from the detector.\nPositionning these elements in 3D space by hand would be unnecessarily complicated. Instead, a utility function OEPlacement() has been written to allow you to automatically position these elements, provided you specify the distances between them and the incidence angle on each element.\nTo position these elements, a prealignment is performed, much like with an alignment laser in real life. A single ray (the central ray within the actual light source) is cast and the Optical Elements are successively positionned in the path of that ray at the specified distance and incidence angle. A reflected ray is then calculated and the algorithm uses it to add the next Optical Element.\nFYI Using mirrors with deformations would previously skew the algorithm as the central ray would get randomly reflected by the deformation in the center of the mirror. This is no longer and issue as during prealignment in the OEPlacement() function, the mirror defects are automatically turned off. It’s perfectly possible to modify the alignment after this prealignment procedure. See for instance here .\nUsing OEPlacement() To use OEPlacement() we logically need:\nA Python list of mirrors or masks to be positionned A source of light to be used for prealignment (a virtual HeNe laser) described by a dict (see SourceProperties ) A list of distances between optics. The first value is the distance between source and first optic. A list of incidence angles of the central ray on the optical elements. ","categories":"","description":"","excerpt":" Summary Use the OEPlacement() function on a list of optical elements, …","ref":"/usage/mainargs/opticalchainlist/","tags":"","title":"OpticalChainList"},{"body":"The code is split into two Python packages:\nAttosecondRayTracing-core that provides the ARTcore module. It contains the actual ray-tracing code, the definitions of the mirrors, sources and detectors. AttosecondRayTracing that provides the ART module and requires AttosecondRayTracing-core as a dependency. It contains the plotting and visualisation functions as well as the analsysis functions. It’s the most user-facing part of the codebase. Unless you really only need the functionality of AttosecondRayTracing-core, we recommend installing AttosecondRayTracing that will pull in the required dependencies.\nBasic installation Using pip If installing using pip, we recommend installing the dependencies in a virtual environment, for instance using\npython -m venv \u003cnew_virtual_environment_folder\u003e This lets you install and use the software without interfering with the system installation of Python.\nThe installation of the package itself couldn’t be easier:\npip install AttosecondRayTracing Using Anaconda Just as with pip, we recommend using a separate virtual environment to install and use ART. TODO actual installation instructions.\nDevelopper installation If you want to contribute to the development of ART or simply want to modify something for your own needs, you can directly download the source code from the github page.\nFor instance:\ngit clone https://github.com/mightymightys/AttosecondRaytracing.git Contributing We appreciate any contributions to the code. The best way to do so is by making pull requests on Github.\n","categories":"","description":"","excerpt":"The code is split into two Python packages:\nAttosecondRayTracing-core …","ref":"/usage/installation/","tags":"","title":"Installation"},{"body":" Some of these examples may be updated without warning\nSome examples of stuff\n","categories":"","description":"Information on how to install the code and the standard way of interacting with it.\n","excerpt":"Information on how to install the code and the standard way of …","ref":"/usage/","tags":"","title":"Installation and Usage"},{"body":" Summary SourceProperties is a python dictionnary Running the simulation requires describing the light source. The properties that need to be defined are the following:\n\"DeltaFT\": This is not actually a property of the light source. Indeed, in the simulation, all photons are considered to be emitted simultaneously in an infinitely short burst. This parameter is actually an analysis parameter, used to check whether the light rays after the optical system have a short enough temporal spread. \"Wavelength\": Similarly to DeltaFT, this is actually an analysis parameter that is used as a reference for the spatial spread of the light rays after the optical system. It can however be used in the future to make wavelength-dependent optics such as gratings. \"Divergence\": This is an actual propertany of the light source: it’s the half-angle of the cone of light emitted by the source as illustrated below. \"SourceSize\": Again, a property of the light source. It’s the diameter of the light source (considered to be a disc). If the light source is a point source, it should be set to 0. \"NumberRays\": The number of rays that the light source will cast and that will be used for the simulation. Below we provide an example of a 5mm wide source of 80nm light with a 50mrad total divergence, casting 1000 rays and compared in the end to an Airy cylinder of 0.5 femtoseconds.\nSourceProperties = { 'Divergence' : 50e-3/2, 'SourceSize' : 5, 'Wavelength' : 80e-6, 'DeltaFT' : 0.5, 'NumberRays' : 1000 } ","categories":"","description":"","excerpt":" Summary SourceProperties is a python dictionnary Running the …","ref":"/usage/mainargs/sourceproperties/","tags":"","title":"SourceProperties"},{"body":"This example configuration describes a refocusing setup comprised of two identical toroidal mirrors with a focal length of 500 and an angle of incidence of 80°. The beam from a point source is first cut to 35mrad by a circular mask, it then impacts the first toroidal mirror positionned one focal length away from the source. A second toroidal mirror is positionned at a variable distance away from the first one. The script will iterate over that distance to try to find the one that minimises the image focal spot size.\nYou can download the configuration file here: CONFIG_2toroidals_f-x-f.py Opening the configuration code, the first lines import the necessary modules, mostly from ARTcore.\nimport ARTcore.ModuleMirror as mmirror import ARTcore.ModuleSupport as msupp import ARTcore.ModuleProcessing as mp import ARTcore.ModuleMask as mmask import ARTcore.ModuleSource as mos import ARTcore.ModuleOpticalChain as moc import ARTcore.ModuleGeometry as mgeo import ARTcore.ModuleDetector as mdet import ART import matplotlib.pyplot as plt import numpy as np Source As far as the raytracing program is concerned, a Source is simply a list of rays. To generate that list of rays we can use the SimpleSource class that is provided by ARTcore. It’s defined by several distributions:\nA spectral distribution An intensity distribution A distribution of origin points A distribution of ray directions The rays are then generated assuming that the distributions are independent. For more complicated sources such as sources where the intensity and angular distributions depend on the wavelength, the users are encouraged to write their own generator of rays.\nIn this particular example we’re going to assume a point source with a gaussian intensity distribution and a uniform cone directions distribution. The spectrum is uniform.\nN_rays = 1000 Spectrum = mos.UniformSpectrum(lambdaMin=30e-6, lambdaMax=800e-6) PowerDistribution = mos.GaussianPowerDistribution(1, 2, 50e-3) Positions = mos.PointRayOriginsDistribution(mgeo.Origin) Directions = mos.ConeRayDirectionsDistribution(mgeo.Vector([1,0,0]), 50e-3) Source = mos.SimpleSource(Spectrum, PowerDistribution, Positions, Directions) SourceRays = Source(N_rays) Optical elements Circular mask After the source, the system has a circular mask.\nSupportMask = msupp.SupportRoundHole(Radius=30, RadiusHole=15, CenterHoleX=0, CenterHoleY=0) Mask = mmask.Mask(SupportMask) MaskSettings = { 'OpticalElement' : Mask, 'Distance' : 400, 'IncidenceAngle' : 0, 'IncidencePlaneAngle' : 0, 'Description' : \"Mask for selecting rays\", 'Alignment' : 'support_normal', } First toroidal mirror The first step is to calculate the toroidal mirror parameters\nFocal = 500 AngleIncidence = 80 #in deg OptimalMajorRadius, OptimalMinorRadius = mmirror.ReturnOptimalToroidalRadii(Focal, AngleIncidence) SupportToroidal = msupp.SupportRectangle(150, 32) Then we can define the first mirror ToroidalMirrorA\nToroidalMirrorA = mmirror.MirrorToroidal(SupportToroidal, OptimalMajorRadius, OptimalMinorRadius) ToroidalASettings = { 'OpticalElement' : ToroidalMirrorA, 'Distance' : Focal-MaskSettings['Distance'], 'IncidenceAngle' : AngleIncidence, 'IncidencePlaneAngle' : 0, 'Description' : \"First parabola for collimation\", } Second toroidal mirror ToroidalMirrorB = mmirror.MirrorToroidal(SupportToroidal,OptimalMajorRadius, OptimalMinorRadius) ToroidalBSettings = { 'OpticalElement' : ToroidalMirrorB, 'Distance' : None, 'IncidenceAngle' : AngleIncidence, 'IncidencePlaneAngle' : 180, 'Description' : \"First parabola for collimation\", } Detector Det = mdet.InfiniteDetector(-1) Detectors = { \"Focus\": Det } Optimising the position of the second mirror ChainDescription = \"2 toroidal mirrors in f-d-f config, i.e. approx. collimation, propagation, and the refocus \" Distances = np.linspace(Focal-200, Focal+200, 20) FocalDistances = [] FocalSizes = [] for d in Distances: ToroidalBSettings['Distance'] = d print(d) AlignedOpticalElements = mp.OEPlacement([MaskSettings, ToroidalASettings, ToroidalBSettings]) AlignedOpticalChain = moc.OpticalChain(Source(1000), AlignedOpticalElements, Detectors, ChainDescription) RayListAnalysed = AlignedOpticalChain.get_output_rays()[-1] Det.autoplace(RayListAnalysed, 390) Det.optimise_distance(RayListAnalysed, [200,600], Det._spot_size, maxiter=10, tol=1e-14) FocalDistances.append(Det.distance) DetectorPointList2D = AlignedOpticalChain.get2dPoints() DetectorPointList2DCentre = DetectorPointList2D - np.mean(DetectorPointList2D, axis=0) FocalSpotSizeSD = np.std(DetectorPointList2DCentre.norm) FocalSizes.append(FocalSpotSizeSD) Plotting optimalDistance = Distances[np.argmin(FocalSizes)] fig, ax = plt.subplots() ax.plot(Distances, FocalSizes) ax.set_xlabel('Distance between PM and Toroidal B [mm]') ax.set_ylabel('Spot size [mm]') ax.scatter(optimalDistance, np.min(FocalSizes), color='red') plt.tight_layout() ToroidalBSettings['Distance'] = optimalDistance AlignedOpticalElements = mp.OEPlacement([MaskSettings, ToroidalASettings, ToroidalBSettings]) AlignedOpticalChain = moc.OpticalChain(Source(5000), AlignedOpticalElements, Detectors, ChainDescription) rays= AlignedOpticalChain.get_output_rays() Det.autoplace(rays[-1], FocalDistances[np.argmin(FocalSizes)]) Det.optimise_distance(rays[-1], [200,600], Det._spot_size, maxiter=10, tol=1e-14) AlignedOpticalChain.render(EndDistance=Det.distance+10, OEpoints=5000, cycle_ray_colors=True, impact_points=True, DetectedRays=True) AlignedOpticalChain.drawSpotDiagram(ColorCoded=\"Delay\") AlignedOpticalChain.drawCaustics() print(\"Optimum found for following parameters:\") print(AlignedOpticalChain) plt.show() ","categories":"","description":"","excerpt":"This example configuration describes a refocusing setup comprised of …","ref":"/examples/config_2toroidals_f-x-f/","tags":"","title":"Two identical toroidals in same plane of incidence"},{"body":"Before starting, we strongly recommend checking out the conventions we use in ART.\nThe entry point into the program is the main() function found in the ARTmain.py file. It has five arguments, one of which is optional:\nOpticalChainList: An OpticalChainList object containing all the optical elements to be simulated with their positions as well as a list of initial source rays. SourceProperties: A dict of the properties of the source that will be used for the light simulation DetectorOptions: A dict describing the position of the light ray detector or the parameters allowing it to be auto-positionned. AnalysisOptions: A dict specifying which plots to display and their options. save_file_name (optional): A file name for saving the raw data to be analysed later. Thus, running the program requires constructing these objects and calling main(). There are two ways to do so:\nConstruct them in a script or in an interactive shell or IPython notebook and call the function. Run the ARTmain.py file as a program and pass a config file as its first argument. Using a configuration file In practice, the config file is simply a Python script similar to what one would write using the first way. The main difference is that it doesn’t contain a call to the main() function.\nIndeed, running ARTmain.py as a standalone program with a config file simply loads the file as a module and checks for the presence of attributes with the same names as the arguments of main().\nThus, to write a config file, you simply have to create variables with the same names as the arguments of main().\nRunning directly Same as with using a config file, you need to create the arguments for the main() function. Calling it will run the program as well as return the raw data for further analysis.\n","categories":"","description":"","excerpt":"Before starting, we strongly recommend checking out the conventions we …","ref":"/usage/usage/","tags":"","title":"Usage"},{"body":" Summary DetectorOptions is a python dictionnary The detector is a virtual plane of infinite size which plays the role of a CCD. It can be positionned manually by specifying the position of a point on the detector and its normal vector. However, in the case of ART it made sense to make the positionning of the detector part of the main functionality of the code. Thus, the main() function accepts the DetectorOptions argument. This object allows the code to automatically position the virtual detection plane in the optimal spot. It’s a Python dictionnary with the following possible attributes:\n\"ReflectionNumber\": This is the number of the optic after the which the detector will be positionned. In most cases that would be the final optic in the setup and we commonly use the Python shorthand for the index of the last element: -1 \"ManualDetector\": Setting this to True would disable the automatic positionning of the detector and you would have to also specify \"DetectorCentre\" and \"DetectorNormal\" to position it. \"AutoDetectorDistance\": If set to True, the algorithm will automatically optimize the detector position based on the \"OptFor\", \"MaxRaystoConsider\" and \"IntensityWeighted\" options. \"DistanceDetector\": If \"AutoDetectorDistance\" is True, it will be the starting point for the optimisation. Otherwise, this will be the distance of the detector from the last optical element. DetectorOptions = { 'ReflectionNumber' : -1, 'ManualDetector' : False, 'DistanceDetector' : 76 , 'AutoDetectorDistance' : True, 'OptFor' : \"intensity\" } ","categories":"","description":"","excerpt":" Summary DetectorOptions is a python dictionnary The detector is a …","ref":"/usage/mainargs/detectoroptions/","tags":"","title":"DetectorOptions"},{"body":" Some of these examples may be updated without warning\nSome examples of stuff\n","categories":"","description":"Some examples of ray-traced systems that you can use as a starting point for your own simulation.\n","excerpt":"Some examples of ray-traced systems that you can use as a starting …","ref":"/examples/","tags":"","title":"Examples"},{"body":" Summary AnalysisOptions is a python dictionnary DefaultAnalysisOptions = { \"verbose\": True, # print intermediate results and info in the console? \"plot_Render\": False, # render optical elements and rays, and how many rays to render? \"maxRaysToRender\": 150, \"DrawAiryAndFourier\": True, # Draw Airy spot and Fourier-limited duration in the following plots? \"plot_SpotDiagram\": False, # produce an interactive spot diagram without color coding the spots? \"plot_DelaySpotDiagram\": False, # produce an interactive spot diagram with ray delays color coded? \"plot_IntensitySpotDiagram\": False, # produce an interactive spot diagram with ray intensities color coded? \"plot_IncidenceSpotDiagram\": False, # produce an interactive spot diagram with ray incidence angles color coded? \"plot_DelayGraph\": False, # produce an interactive spot diagram with delays in 3rd dimension? \"plot_IntensityGraph\": False, # produce an interactive spot diagram with delays in 3rd dimension and ray intensities color coded? \"plot_IncidenceGraph\": False, # produce an interactive spot diagram with delays in 3rd dimension and ray incidence angles color coded? \"plot_DelayMirrorProjection\": False, # produce a plot of the ray delays at the detector projected onto the mirror surface? \"plot_IntensityMirrorProjection\": False, # produce a plot of the ray intensities at the detector projected onto the mirror surface? \"plot_IncidenceMirrorProjection\": False, # produce a plot of the ray incidence angles at the detector projected onto the mirror surface? \"save_results\": True, # save the simulation results to disk, to analyse later \"OEPointsToRender\": 2000, \"OEPointsScale\": 0.5, } ","categories":"","description":"","excerpt":" Summary AnalysisOptions is a python dictionnary …","ref":"/usage/mainargs/analysisoptions/","tags":"","title":"AnalysisOptions"},{"body":" This is a placeholder page that shows you how to use this template site.\nDo you have any example applications or code for your users in your repo or elsewhere? Link to your examples here.\n","categories":"","description":"See your project in action!\n","excerpt":"See your project in action!\n","ref":"/articles/","tags":"","title":"Articles"},{"body":"In the ART code, we use some conventions. In order to obtain the expected results, please use those conventions.\nUnits The distances in ART are in millimeters. The angles are stored and calculated in radians, but for input/output, they are converted to degrees.\nIncidence planes The default incidence plane is \\((\\vec{x},\\vec{z} )\\), with \\(\\vec{z}\\) being the default propagation direction. All elements are created by default with a normal vector pointing towards positive \\(\\vec{z}\\). For a horizontal incidence plane, this means that \\(\\vec{y}\\) is the vertical axis.\nOrientation Some objects that are manipulated by ART are best seen as solid objects, that have 6 degrees of freedom (6DOF). That means that we can calculate the position of any point on that object if we agree on the definition of a basepoint around which to perform calculations and:\nA translation vector \\(\\v r\\) that describes the position of the basepoint A rotation quaternion \\(\\mathfrak{q}\\) that describes how the object has been rotated around that basepoint. Essentially, every optical element is defined initially in the lab reference frame in a certain orientation and position. All the special points and vectors of the object are defined in that orientation and position. The object is then translated and rotated around the basepoint to bring it to its final position.\nThe initial position and orientation of the object define its reference frame, and for each type of object you should refer to the schematic drawing in the documentation in order to know how the actual object is positionned within that reference frame. In the code, the attributes of an object as defined within its reference frame are annotated with _ref.\nThe illustration below shows the formulas allowing to go from one reference frame to the other for both a point \\(P\\) on the object and a direction vector \\(\\vec{v}\\). In the drawing, \\(C\\) is the basepoint.\nImportant vectors As mentionned above, an object in ART is defined initially within its own reference frame. Considering the case of an ellipsoidal mirror, the python object will contain an attribute “Support” that defines the overall shape of the mirror and is in the \\((\\vec{x_0},\\vec{y_0})\\) of the object reference frame. The points of the mirror are defined as a function \\(z_0(x_0,y_0)\\). And we also define a few important vectors: support_normal (that is always [0,0,1]), focus_1 and focus_2 that point from the center of the mirror to the focal points.\nTODO this whole section\nDespite its name, the “normal” vector has got nothing to do with normal incidence on an optic. Indeed, a better name would be “support_normal” or “standard” vector. Generally, it’s the vector normal to the support of each optic. To see what it corresponds to with respect to the optical axes, one should look at the documentation of each type of mirror Understanding how this vector is oriented is critical to properly aligning the optical system.\n","categories":"","description":"Conventions used in the ART code.\n","excerpt":"Conventions used in the ART code.\n","ref":"/conventions/","tags":"","title":"Conventions"},{"body":" Some of these examples may be updated without warning\nWhether using a config file or passing the arguments directly to main(), we need to build the objects to be passed to the program. These pages are a quick description of each parameter and how to build them.\n","categories":"","description":"See your project in action!\n","excerpt":"See your project in action!\n","ref":"/usage/mainargs/","tags":"","title":"Writing config file"},{"body":"","categories":"","description":"","excerpt":"","ref":"/addons-api/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/modified-api/","tags":"","title":""},{"body":"\nThis documentation web page is a work in progress. Please do not hesitate to raise issues in the Github repository of the project.\nThe AttosecondRayTracing code is a tool for the attosecond-physics community to assist with the design of beam transport and refocusing setups.\nIt is written by Stefan Haessler, André Kalouguine, and Anthony Guillaume of Laboratoire d’Optique Appliquée (LOA), CNRS, Institut Polytechnique de Paris, France and Charles Bourassin-Bouchet Laboratoire Charles Fabry (LCF)), Institut d’Optique, CNRS, Université Paris-Saclay, France .\nIt does ray tracing calculations for (a succession of) reflective optics, freely arrangeable including grazing incidence configurations. It keeps track of the optical paths of each ray and therefore supplies precise information about the delays with which the rays hit a virtual detector plane. These can –within the limits of geometric optics– describe spatio-temporal distortions introduced by aberrations of the optical setup.\nSuch calculations were already published by Charles ten years ago for single-mirror setups, demonstrating how sensitive attosecond pulses are to spatio-temporal distortions and how easily such distortions are picked up in the reflective grazing-incidence optical setups required to transport and refocus them [ C. Bourassin-Bouchet et al. “How to focus an attosecond pulse”. Opt. Express 21, 2506 (2013) ; C. Bourassin-Bouchet et al. “Spatiotemporal distortions of attosecond pulses”. JOSA A 27, 1395 (2010) ].\nA publication of simulations of the beam transport and focusing of high-numerical-aperture XUV attosecond pulses with multi-mirror setups is in preparation and will become the reference that we ask you to cite if you have used this code in your work.\nPlease start by reading the Installation and Usage pages.\n","categories":"","description":"","excerpt":"\nThis documentation web page is a work in progress. Please do not …","ref":"/","tags":"","title":"Attosecond Ray Tracing"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]